#!/usr/bin/env ruby

require 'set'
require 'optparse'
require 'pathname'

CONFIG_DIR = Pathname.new(ENV['PKGSET_DIR'] || '/etc/pkgset')
SET_DIR = CONFIG_DIR + 'sets'
INSTALL_DIR = CONFIG_DIR + 'installed-sets'

class PkgsetError < StandardError; end

def join_lines(x)
    x.join("\n") + "\n"
end

def map_lines(path, &block)
    old_contents = path.readlines
    new_contents = old_contents.map(&block).reject(&:nil?)

    if old_contents != new_contents
        path.open('w') do |f|
            f.write(new_contents.join("\n") + "\n")
        end
    end
end

class PackageSet
    attr_reader :name

    def initialize(name)
        @name = name
        @path = SET_DIR + name
    end

    def to_s
        @name
    end

    def ==(other)
        @name == other.name
    end

    alias_method :eql?, :==

    def hash
        @name.hash
    end

    def self.[](name)
        # TODO existence check
        s = new(name)
        raise PkgsetError, "no such set '#{s}'" unless s.exist?
        s
    end

    def create(pkgs)
        raise if @path.exist?
        merge(pkgs)
    end

    def self.all
        all = SET_DIR.children(false).map { |n| self[n.basename.to_s] }
        Set.new(all)
    end

    def self.accumulate(pkgsets)
        pkgsets.reduce(Set.new) { |a, s| a.merge(s.get) }
    end

    def self.all_installed
        installed = INSTALL_DIR.children(false).map { |n| self[n.basename.to_s] }
        Set.new(installed)
    end

    def exist?
        @path.exist?
    end

    def get
        lines = @path.readlines.map { |line| line.strip }
        pkgs = lines.reject { |line| line.start_with?('#') or line.empty? }
        Set.new(pkgs)
    end

    def mark_installed
        link = INSTALL_DIR + @name
        if !link.symlink?
            target = @path.relative_path_from(INSTALL_DIR)
            link.make_symlink(target)
        end
    end

    def mark_uninstalled
        link = INSTALL_DIR + @name
        link.delete if link.symlink?
    end

    def installed?
        (INSTALL_DIR + @name).symlink?
    end

    def merge(pkgs)
        @path.open('a+') do |f|
            existing = f.readlines.map { |l| l.strip }
            extra = pkgs - existing
            f.write(extra.to_a.join("\n"))
            f.write("\n")
            return Set.new(extra)
        end
    end

    def remove(pkgs)
        map_lines(@path) do |line|
            line unless pkgs.include?(line.strip)
        end
    end

    def replace(old_name, new_name)
        map_lines(@path) do |line|
            line = "#{new_name}\n" if line.strip == old_name
            line
        end
    end
end

def xargs(command, args)
    # TODO implement xargs behaviour
    if !args.empty?
        system(*(command + args))
    else
        true
    end
end

def cmd_to_set(command)
    IO.popen(command) do |f|
        return Set.new(f.readlines.map { |l| l.strip })
    end
end

class PackageManagerAPI
    def initialize(program)
        @program = program
    end
end

class PacmanAPI < PackageManagerAPI
    def explicitly_installed
        cmd_to_set(%w[pacman -Qeq])
    end

    def install(pkgs)
        xargs([@program, '-S', '--needed'], pkgs) \
        && xargs([@program, '-D', '--asexplicit'], pkgs)
    end

    def uninstall(pkgs, purge:)
        xargs([@program, '-D', '--asdeps'], pkgs)
    end
end

def which(program)
    system('which', program, [:out, :err] => '/dev/null')
end

def prepare
    CONFIG_DIR.mkpath
    SET_DIR.mkpath
    INSTALL_DIR.mkpath

    alias_ = ENV['PKGSET_ALIAS']
    $api = if which('pacman')
        PacmanAPI.new(alias_ || 'pacman')
    else
        raise PkgsetError, "can't find any supported package manager"
    end
end

def main
    case ARGV.shift
    when 'install'
        prepare

        set_names = ARGV
        sets = set_names.map do |name|
            PackageSet[name]
        end

        to_install = PackageSet.accumulate(sets)

        if $api.install(to_install.to_a)
            sets.each do |set|
                set.mark_installed
            end
        end

    when 'add'
        opts = {}
        OptionParser.new do |op|
            op.on('-h', '--help') do
                puts <<~USAGE
                    Usage: pkgset add [-n] SET PACKAGE...

                    Add packages to the given set. If the set is marked as installed, the packages
                    will be installed with the package manager.

                    Options:
                    -h, --help    Show this help message
                USAGE
                exit
            end
            op.on('-n', '--new')
            op.on('-i', '--installed')
        end.order!(into: opts)

        prepare

        set_name = ARGV.shift
        set = if opts[:new]
            s = PackageSet.new(set_name)
            s.mark_installed if opts[:installed]
            s
        else
            PackageSet[set_name]
        end

        packages = ARGV

        # Add if the set is not installed or the package install command succeeds
        if !set.installed? || $api.install(packages)
            set.merge(packages)
        end

    when 'remove'
        opts = {}
        OptionParser.new do |op|
            op.on('-p', '--purge')
        end.order!(into: opts)

        set_name = ARGV.shift

        prepare

        set = PackageSet[set_name]
        packages = Set.new(ARGV)

        # We only need to uninstall packages which aren't in another set
        other_pkgs = PackageSet.accumulate(PackageSet.all.delete(set))
        to_uninstall = packages - other_pkgs

        # Remove the selected packages if either the set is uninstalled, or our
        # package uninstall command works
        if !set.installed? || $api.uninstall(to_uninstall.to_a, purge: opts[:purge])
            set.remove(packages)
        end

    when 'uninstall'
        opts = {}
        OptionParser.new do |op|
            op.on('-p', '--purge')
        end.order!(into: opts)

        set_names = ARGV

        if set_names.empty?
            raise PkgsetError, "no sets specified"
        end

        prepare

        sets = set_names.map do |name|
            PackageSet[name]
        end

        to_uninstall = Set.new
        sets.each do |set|
            if set.installed?
                to_uninstall << set
            else
                puts "set '#{set}' not installed, skipping"
            end
        end

        # Remove packages in any of the given sets that aren't in any other installed sets.
        remaining_sets = PackageSet.all_installed - to_uninstall
        uninstall_pkgs = PackageSet.accumulate(to_uninstall) - PackageSet.accumulate(remaining_sets)

        if $api.uninstall(uninstall_pkgs.to_a, purge: opts[:purge])
            to_uninstall.each do |s|
                puts "uninstalling set '#{s}'"
                s.mark_uninstalled
            end
        end

    when 'unadded'
        prepare

        in_set = PackageSet.accumulate(PackageSet.all)
        in_system = $api.explicitly_installed

        (in_system - in_set).each do |pkg|
            puts pkg
        end

    when 'replace-all'
        prepare

        old_name = ARGV.shift
        new_name = ARGV.shift

        PackageSet.all.each do |set|
            set.replace(old_name, new_name)
        end

    when 'list'
        prepare

        if ARGV.empty?
            lines = PackageSet.all.map do |s|
                sym = s.installed? ? '*' : ' '
                "#{sym} #{s.name}"
            end
            puts join_lines(lines)
        else
            set = PackageSet[ARGV.shift]
            puts join_lines(set.get.to_a)
        end
    end
end

begin
    main
rescue PkgsetError => exc
    puts "error: #{exc}"
end
