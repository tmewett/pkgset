#!/usr/bin/env ruby

require 'set'
require 'optparse'
require 'pathname'

CONFIG_DIR = Pathname.new(ENV['PKGSET_DIR'] || '/etc/pkgset')
SET_DIR = CONFIG_DIR + 'sets'
INSTALL_DIR = CONFIG_DIR + 'installed-sets'

class PkgsetError < StandardError; end

class PackageSet
    attr_reader :name

    def initialize(name)
        @name = name
        @path = SET_DIR + name
    end

    def to_s
        @name
    end

    def ==(other)
        @name == other.name
    end

    alias_method :eql?, :==

    def hash
        @name.hash
    end

    def self.[](name)
        # TODO existence check
        s = new(name)
        raise PkgsetError, "no such set '#{s}'" unless s.exist?
        s
    end

    def create(pkgs)
        raise if @path.exist?
        merge(pkgs)
    end

    def self.list
        SET_DIR.children(false).map { |n| self[n.basename.to_s] }
    end

    def self.accumulate(pkgsets)
        pkgsets.reduce(Set.new) { |a, s| a.merge(s.get) }
    end

    def self.list_installed
        INSTALL_DIR.children(false).map { |n| self[n.basename.to_s] }
    end

    def exist?
        @path.exist?
    end

    def get
        lines = @path.readlines.map { |line| line.strip }
        pkgs = lines.reject { |line| line.start_with?('#') or line.empty? }
        Set.new(pkgs)
    end

    def mark_installed
        target = @path.relative_path_from(INSTALL_DIR)
        (INSTALL_DIR + @name).make_symlink(target)
    end

    def mark_uninstalled
        link = INSTALL_DIR + @name
        link.delete if link.exist?
    end

    def installed?
        (INSTALL_DIR + @name).exist?
    end

    def merge(pkgs)
        @path.open('a+') do |f|
            existing = f.readlines.map { |l| l.strip }
            extra = pkgs - existing
            f.write(extra.to_a.join("\n"))
            f.write("\n")
            return Set.new(extra)
        end
    end

    def remove(pkgs)
        old_contents = @path.readlines
        @path.open('w') do |f|
            old_contents.each do |line|
                f.write(line) unless pkgs.include?(line.strip)
            end
        end
    end

    def replace(old_name, new_name)
        # TODO Line-based to a temp file?
        old_contents = @path.readlines
        @path.open('w') do |f|
            old_contents.each do |line|
                line = "#{new_name}\n" if line.strip == old_name
                f.write(line)
            end
        end
    end
end

def xargs(command, args)
    # TODO implement xargs behaviour
    system(*(command + args))
end

def cmd_to_set(command)
    IO.popen(command) do |f|
        return Set.new(f.readlines.map { |l| l.strip })
    end
end

class PacmanAPI
    def list_explicit
        cmd_to_set(%w[pacman -Qeq])
    end

    def install(pkgs)
        xargs(['pacman', '-S', '--needed'], pkgs) \
        && xargs(['pacman', '-D', '--asexplicit'], pkgs)
    end

    def _unneeded
        cmd_to_set(%w[pacman -Qdtq])
    end

    def uninstall(pkgs, purge:)
        cmd = ['pacman', '-R']
        cmd << '-n' if purge
        xargs(%w[pacman -D --asdeps], pkgs) \
        && xargs(cmd, _unneeded.to_a)
    end
end

def ensure_dir(path)
    # TODO full mkdir -p
    path.mkdir unless path.exist?
end

def prepare
    CONFIG_DIR.mkpath
    SET_DIR.mkpath
    INSTALL_DIR.mkpath

    # TODO detection
    $api = PacmanAPI.new
end

def wrap(text, width)
    lines = [[]]
    length = -1
    text.split.each do |word|
        lines[-1] << word
        length += word.length + 1
        if length > width
            length = -1
            lines << []
        end
    end
    lines.map { |l| l.join(' ') }
end

def puts_columns(left, right)
    left_margin = 2
    left_width = 25
    total_limit = 80
    out = []
    right_lines = wrap(right, total_limit - (left_width + left_margin))

    margin = ' ' * left_margin
    if left.length > left_width
        puts(margin + left)
    else
        puts(margin + left + ' ' * (left_width - left.length) + right_lines.shift)
    end

    right_lines.each { |line| puts(' ' * (left_width + left_margin) + line) }
end

def main
    case ARGV.shift
    when 'install'
        prepare

        set_names = ARGV
        sets = set_names.map do |name|
            PackageSet[name]
        end

        to_install = PackageSet.accumulate(sets)

        if $api.install(to_install.to_a)
            sets.each do |set|
                set.mark_installed
            end
        end

    when 'add'
        opts = {}
        OptionParser.new do |op|
            op.on('-h', '--help') do
                puts <<~USAGE
                    Usage: pkgset add [-n] SET PACKAGE...

                    Add packages to the given set. If the set is marked as installed, the packages
                    will be installed with the package manager.

                    Options:
                    -h, --help    Show this help message
                USAGE
                exit
            end
            op.on('-n', '--new')
            op.on('-i', '--installed')
        end.order!(into: opts)

        prepare

        set_name = ARGV.shift
        set = if opts[:new]
            s = PackageSet.new(set_name)
            s.mark_installed if opts[:installed]
            s
        else
            PackageSet[set_name]
        end

        packages = ARGV

        # Add if the set is not installed or the package install command succeeds
        if !set.installed? || $api.install(packages)
            set.merge(packages)
        end

    when 'remove'
        opts = {}
        OptionParser.new do |op|
            op.on('-p', '--purge')
        end.order!(into: opts)

        set_name = ARGV.shift

        prepare

        set = PackageSet[set_name]
        packages = ARGV

        # We only need to uninstall packages which aren't in another set
        other_pkgs = PackageSet.accumulate(PackageSet.list.delete(set))
        to_uninstall = packages - other_pkgs

        # Remove the selected packages if either the set is uninstalled, or our
        # package uninstall command works
        if !set.installed? || $api.uninstall(to_uninstall.to_a, purge: opts[:purge])
            set.remove(packages)
        end

    when 'uninstall'
        opts = {}
        OptionParser.new do |op|
            op.on('-p', '--purge')
        end.order!(into: opts)

        set_names = ARGV

        if set_names.empty?
            raise PkgsetError, "no sets specified"
        end

        prepare

        sets = set_names.map do |name|
            PackageSet[name]
        end

        to_uninstall = Set.new
        sets.each do |set|
            if set.installed?
                to_uninstall << set
            else
                puts "set '#{set}' not installed, skipping"
            end
        end

        # Remove packages in any of the given sets that aren't in any other installed sets.
        remaining_sets = Set.new(PackageSet.list_installed) - to_uninstall
        uninstall_pkgs = PackageSet.accumulate(to_uninstall) - PackageSet.accumulate(remaining_sets)

        if $api.uninstall(uninstall_pkgs.to_a, purge: opts[:purge])
            to_uninstall.each do |s|
                puts "uninstalling set '#{s}'"
                s.mark_uninstalled
            end
        end

    when 'unadded'
        prepare

        in_set = PackageSet.accumulate(PackageSet.list)
        in_system = $api.list_explicit

        (in_system - in_set).each do |pkg|
            puts pkg
        end

    when 'replace-all'
        prepare

        old_name = ARGV.shift
        new_name = ARGV.shift

        PackageSet.list.each do |set|
            set.replace(old_name, new_name)
        end
    end
end

begin
    main
rescue PkgsetError => exc
    puts "error: #{exc}"
end
